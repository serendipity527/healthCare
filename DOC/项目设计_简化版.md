# 智能医疗助手 Agent - 简化版设计文档

> 基于 **LangChain4j + WebSocket** 的 MVP 架构方案（不使用 LangGraph4j）

## 🏗️ 项目架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         前端层 (Frontend)                        │
├─────────────────────────────────────────────────────────────────┤
│  Vue 3 / React / 原生 HTML + JS                                 │
│  └─ WebSocket Client (实时对话)                                 │
└────────────────────────────┬────────────────────────────────────┘
                             │ WebSocket 连接
┌────────────────────────────▼────────────────────────────────────┐
│                    WebSocket 网关层                              │
├─────────────────────────────────────────────────────────────────┤
│  WebSocketHandler                                               │
│  ├─ 消息路由                                                     │
│  ├─ 会话管理 (SessionManager)                                   │
│  └─ 消息序列化/反序列化                                          │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                  核心业务层 (Core Service)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────┐     │
│  │         简单状态管理器 (State Manager)                │     │
│  ├───────────────────────────────────────────────────────┤     │
│  │                                                       │     │
│  │  状态流程：                                            │     │
│  │                                                       │     │
│  │  [用户消息]                                           │     │
│  │      ↓                                                │     │
│  │  ┌──────────────────────────────────────┐            │     │
│  │  │  状态判断逻辑 (SessionState)         │            │     │
│  │  │  - GREETING: 欢迎阶段                │            │     │
│  │  │  - COLLECTING: 信息收集中            │            │     │
│  │  │  - ANALYZING: 分析信息完整度         │            │     │
│  │  │  - RECOMMENDING: 生成推荐            │            │     │
│  │  │  - COMPLETED: 完成                   │            │     │
│  │  └──────────────────────────────────────┘            │     │
│  │      ↓                                                │     │
│  │  根据状态调用对应的处理器 (Handler)                   │     │
│  │      ↓                                                │     │
│  │  ┌──────────────────────────────────────┐            │     │
│  │  │  GreetingHandler                     │            │     │
│  │  │  CollectingHandler (主要)            │            │     │
│  │  │  RecommendHandler                    │            │     │
│  │  └──────────────────────────────────────┘            │     │
│  │      ↓                                                │     │
│  │  返回响应 + 更新状态                                   │     │
│  │                                                       │     │
│  └───────────────────────────────────────────────────────┘     │
│                             │                                  │
│  ┌──────────────────────────▼──────────────────────────┐       │
│  │          LangChain4j AI Service 层                   │       │
│  ├──────────────────────────────────────────────────────┤       │
│  │  • ChatLanguageModel (对话模型)                      │       │
│  │  • AiServices (AI 服务接口)                          │       │
│  │  • ChatMemory (对话记忆 - MessageWindowChatMemory)   │       │
│  │  • PromptTemplate (提示词模板)                       │       │
│  │  • @Tool 方法 (工具函数调用)                         │       │
│  └──────────────────────────────────────────────────────┘       │
│                             │                                  │
└─────────────────────────────┼──────────────────────────────────┘
                              │
┌─────────────────────────────▼────────────────────────────────────┐
│                      数据访问层 (Data Layer)                      │
├──────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ ConcurrentMap   │  │ JSON Files      │  │ Redis (可选)    │  │
│  ├─────────────────┤  ├─────────────────┤  ├─────────────────┤  │
│  │ • 会话状态      │  │ • 医生数据      │  │ • 会话持久化    │  │
│  │ • 对话历史      │  │ • 药物知识库    │  │ • 分布式缓存    │  │
│  │ • 收集的信息    │  │ • 疾病映射      │  │                 │  │
│  │ (内存级别)      │  │                 │  │                 │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
└──────────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────▼────────────────────────────────────┐
│                      外部服务层 (External)                        │
├──────────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐                     │
│  │ OpenAI API       │  │ 通义千问 API      │  (选择一个)         │
│  │ GPT-4 / GPT-3.5  │  │ 或其他国产 LLM    │                     │
│  └──────────────────┘  └──────────────────┘                     │
└──────────────────────────────────────────────────────────────────┘
```

## 📋 实现思路

### **1️⃣ 简化的状态管理设计**

**不使用复杂的状态机框架，使用简单的状态模式：**

```java
// 状态枚举
public enum SessionState {
    GREETING,       // 初始欢迎
    COLLECTING,     // 信息收集中（核心状态）
    ANALYZING,      // 分析中（内部状态，用户不感知）
    RECOMMENDING,   // 推荐中
    COMPLETED       // 完成
}

// 状态处理器接口
public interface StateHandler {
    StateResponse handle(SessionContext context, String userMessage);
}

// 核心流程
1. 用户发送消息
2. StateManager 根据当前状态选择对应的 Handler
3. Handler 调用 LangChain4j AI Service
4. AI Service 提取信息 / 生成回复 / 调用工具
5. Handler 更新 SessionContext（状态、收集的信息）
6. 返回响应给用户
```

**状态转换逻辑：**

```
GREETING → COLLECTING
    触发条件：用户开始描述症状

COLLECTING → COLLECTING
    触发条件：信息不完整，继续收集

COLLECTING → RECOMMENDING
    触发条件：必要信息收集完成（由 AI 判断）

RECOMMENDING → COMPLETED
    触发条件：推荐完成

COMPLETED → COLLECTING
    触发条件：用户有新的问题（重新开始）
```

### **2️⃣ 必须收集的信息字段**

```java
@Data
@Builder
public class PatientInfo {
    private String age;              // 年龄 ✓ 必需
    private String gender;           // 性别 ✓ 必需
    private String mainSymptom;      // 主要症状 ✓ 必需
    private String duration;         // 持续时间 ✓ 必需
    private String severity;         // 严重程度（轻度/中度/重度）
    private String accompanySymptoms;// 伴随症状
    private String medicalHistory;   // 既往病史
    private String allergies;        // 过敏史
    private String location;         // 症状部位
    
    // 计算信息完整度
    public int getCompleteness() {
        int score = 0;
        if (age != null) score += 25;
        if (gender != null) score += 25;
        if (mainSymptom != null) score += 30;
        if (duration != null) score += 20;
        return score;
    }
    
    public boolean isReadyForRecommendation() {
        return getCompleteness() >= 80;
    }
}
```

### **3️⃣ LangChain4j AI Service 设计**

使用 LangChain4j 的 `AiServices` 接口定义 AI 助手：

```java
public interface MedicalAssistant {
    
    // 信息提取工具
    @SystemMessage("""
        你是一个专业的医疗信息收集助手。
        从用户的描述中提取关键医疗信息（年龄、性别、症状、持续时间等）。
        如果信息不足，生成友好的追问。
        """)
    String collectInformation(String userMessage);
    
    // 推荐医生
    @SystemMessage("根据患者信息推荐合适的医生和科室")
    String recommendDoctor(
        @V("patientInfo") PatientInfo patientInfo,
        @V("doctors") List<Doctor> availableDoctors
    );
    
    // 推荐药物
    @SystemMessage("""
        根据症状推荐非处方药物。
        必须包含免责声明：本建议仅供参考，不能替代专业医疗诊断。
        """)
    String recommendMedicine(
        @V("patientInfo") PatientInfo patientInfo
    );
}
```

### **4️⃣ LangChain4j Tools（工具函数）**

```java
public class MedicalTools {
    
    @Tool("从对话中提取患者信息，返回 JSON 格式")
    public String extractPatientInfo(String conversation) {
        // 使用 AI 从对话中提取结构化信息
        // 返回 PatientInfo 的 JSON
    }
    
    @Tool("检查信息完整度，返回缺失的字段")
    public String checkCompleteness(PatientInfo info) {
        List<String> missing = new ArrayList<>();
        if (info.getAge() == null) missing.add("年龄");
        if (info.getGender() == null) missing.add("性别");
        if (info.getMainSymptom() == null) missing.add("主要症状");
        if (info.getDuration() == null) missing.add("持续时间");
        return missing.isEmpty() ? "完整" : "缺失：" + String.join("、", missing);
    }
    
    @Tool("根据症状推荐科室")
    public String recommendDepartment(String symptom) {
        // 症状关键词映射到科室
        Map<String, String> symptomDeptMap = Map.of(
            "头痛", "神经内科",
            "发烧", "内科",
            "咳嗽", "呼吸科",
            "胃痛", "消化内科",
            "皮疹", "皮肤科"
        );
        // ... 实际实现会更复杂
    }
    
    @Tool("搜索医生")
    public List<Doctor> searchDoctors(String department, String specialty) {
        // 从数据库或 JSON 文件中查询医生
    }
}
```

## 📂 项目结构（简化版）

```
healthCare/
├── pom.xml
├── src/
│   ├── main/
│   │   ├── java/com/yihu/agent/
│   │   │   ├── HealthCareApplication.java
│   │   │   │
│   │   │   ├── config/                       # 配置层
│   │   │   │   ├── WebSocketConfig.java
│   │   │   │   ├── LangChainConfig.java      (配置 ChatLanguageModel)
│   │   │   │   └── CorsConfig.java
│   │   │   │
│   │   │   ├── websocket/                    # WebSocket 层
│   │   │   │   ├── ChatWebSocketHandler.java (核心)
│   │   │   │   └── SessionManager.java       (管理 WebSocket 会话)
│   │   │   │
│   │   │   ├── state/                        # 状态管理（替代 LangGraph）
│   │   │   │   ├── SessionState.java         (状态枚举)
│   │   │   │   ├── SessionContext.java       (会话上下文)
│   │   │   │   ├── StateManager.java         (状态管理器 - 核心)
│   │   │   │   └── handlers/                 (状态处理器)
│   │   │   │       ├── StateHandler.java     (接口)
│   │   │   │       ├── GreetingHandler.java
│   │   │   │       ├── CollectingHandler.java (核心处理器)
│   │   │   │       ├── RecommendHandler.java
│   │   │   │       └── CompletedHandler.java
│   │   │   │
│   │   │   ├── service/                      # 业务服务层
│   │   │   │   ├── MedicalAssistantService.java  (LangChain4j AiService)
│   │   │   │   ├── InfoExtractionService.java    (信息提取)
│   │   │   │   ├── RecommendationService.java    (推荐引擎)
│   │   │   │   └── ChatMemoryService.java        (对话记忆管理)
│   │   │   │
│   │   │   ├── tools/                        # LangChain4j Tools
│   │   │   │   ├── MedicalTools.java         (所有 @Tool 方法)
│   │   │   │   ├── InfoChecker.java
│   │   │   │   ├── DoctorSearcher.java
│   │   │   │   └── MedicineSearcher.java
│   │   │   │
│   │   │   ├── model/                        # 数据模型
│   │   │   │   ├── dto/
│   │   │   │   │   ├── ChatMessage.java
│   │   │   │   │   ├── PatientInfo.java      (核心数据模型)
│   │   │   │   │   ├── StateResponse.java
│   │   │   │   │   └── RecommendationResult.java
│   │   │   │   └── entity/
│   │   │   │       ├── Doctor.java
│   │   │   │       └── Medicine.java
│   │   │   │
│   │   │   ├── repository/                   # 数据访问层
│   │   │   │   ├── DoctorRepository.java     (读取 JSON)
│   │   │   │   ├── MedicineRepository.java
│   │   │   │   └── SessionRepository.java    (内存/Redis)
│   │   │   │
│   │   │   └── constant/                     # 常量
│   │   │       ├── PromptConstants.java      (提示词常量)
│   │   │       └── StateConstants.java
│   │   │
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── prompts/                      # 提示词模板
│   │       │   ├── system-greeting.txt
│   │       │   ├── info-collection.txt
│   │       │   ├── info-extraction.txt
│   │       │   └── recommendation.txt
│   │       └── data/                         # 初始数据
│   │           ├── doctors.json
│   │           ├── medicines.json
│   │           └── symptom-department-mapping.json
│   │
│   └── test/
│       └── java/com/yihu/agent/
│           ├── HealthCareApplicationTests.java
│           └── service/
│               └── MedicalAssistantServiceTest.java
│
├── frontend/                                 # 简单前端
│   ├── index.html
│   ├── chat.js
│   └── style.css
│
├── DOC/
│   └── 项目设计_简化版.md (本文档)
│
└── README.md
```

## 🔧 核心实现流程

### **消息流转流程（简化版）**

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户通过 WebSocket 发送消息                               │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 2. ChatWebSocketHandler.handleTextMessage()                │
│    - 解析消息                                                │
│    - 获取 sessionId                                         │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 3. SessionManager.getOrCreateContext(sessionId)             │
│    - 从内存/Redis 获取 SessionContext                        │
│    - 包含：当前状态、PatientInfo、对话历史                   │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 4. StateManager.process(context, userMessage)               │
│    - 根据 context.getCurrentState() 选择 Handler            │
│    - 调用对应的 Handler.handle()                            │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 5. Handler 执行（以 CollectingHandler 为例）                │
│    ├─ 调用 InfoExtractionService.extract(userMessage)      │
│    │  └─ 使用 LangChain4j AI Service + Tools                │
│    │     提取结构化信息，更新 PatientInfo                     │
│    │                                                         │
│    ├─ 检查信息完整度                                         │
│    │  └─ patientInfo.isReadyForRecommendation()            │
│    │                                                         │
│    ├─ 如果完整：                                             │
│    │  └─ 转换状态到 RECOMMENDING                            │
│    │                                                         │
│    └─ 如果不完整：                                           │
│       └─ 使用 AI 生成追问                                    │
│          └─ aiService.generateQuestion(patientInfo)        │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 6. 更新 SessionContext                                      │
│    - 更新状态                                                │
│    - 保存 PatientInfo                                       │
│    - 添加对话历史到 ChatMemory                               │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 7. 返回 StateResponse                                       │
│    - message: AI 的回复                                     │
│    - state: 当前状态                                        │
│    - data: 附加数据（如推荐结果）                            │
└────────────────────┬────────────────────────────────────────┘
                     ↓
┌────────────────────▼────────────────────────────────────────┐
│ 8. WebSocket 发送响应给前端                                  │
└─────────────────────────────────────────────────────────────┘
```

### **关键代码示例**

#### StateManager.java (核心调度器)

```java
@Service
@RequiredArgsConstructor
public class StateManager {
    
    private final Map<SessionState, StateHandler> handlers;
    
    @PostConstruct
    public void init() {
        handlers = Map.of(
            SessionState.GREETING, greetingHandler,
            SessionState.COLLECTING, collectingHandler,
            SessionState.RECOMMENDING, recommendHandler,
            SessionState.COMPLETED, completedHandler
        );
    }
    
    public StateResponse process(SessionContext context, String userMessage) {
        SessionState currentState = context.getCurrentState();
        StateHandler handler = handlers.get(currentState);
        
        if (handler == null) {
            throw new IllegalStateException("No handler for state: " + currentState);
        }
        
        return handler.handle(context, userMessage);
    }
}
```

#### CollectingHandler.java (核心处理器)

```java
@Service
@RequiredArgsConstructor
public class CollectingHandler implements StateHandler {
    
    private final MedicalAssistantService aiService;
    private final InfoExtractionService extractionService;
    
    @Override
    public StateResponse handle(SessionContext context, String userMessage) {
        // 1. 提取信息
        PatientInfo updatedInfo = extractionService.extract(
            context.getPatientInfo(), 
            userMessage
        );
        context.setPatientInfo(updatedInfo);
        
        // 2. 检查完整度
        if (updatedInfo.isReadyForRecommendation()) {
            // 信息足够，转到推荐状态
            context.setState(SessionState.RECOMMENDING);
            String message = "好的，我已经了解了您的情况。正在为您推荐合适的医生...";
            return StateResponse.builder()
                .message(message)
                .state(SessionState.RECOMMENDING)
                .build();
        } else {
            // 信息不足，生成追问
            String question = aiService.generateFollowUpQuestion(updatedInfo);
            return StateResponse.builder()
                .message(question)
                .state(SessionState.COLLECTING)
                .build();
        }
    }
}
```

## 📦 核心依赖 (pom.xml)

```xml
<properties>
    <java.version>17</java.version>
    <spring.boot.version>3.2.0</spring.boot.version>
    <langchain4j.version>0.35.0</langchain4j.version>
</properties>

<dependencies>
    <!-- Spring Boot Core -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- WebSocket -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    
    <!-- LangChain4j Core -->
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j</artifactId>
        <version>${langchain4j.version}</version>
    </dependency>
    
    <!-- LangChain4j OpenAI Integration -->
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j-open-ai</artifactId>
        <version>${langchain4j.version}</version>
    </dependency>
    
    <!-- LangChain4j Spring Boot Starter -->
    <dependency>
        <groupId>dev.langchain4j</groupId>
        <artifactId>langchain4j-spring-boot-starter</artifactId>
        <version>${langchain4j.version}</version>
    </dependency>
    
    <!-- Redis (可选，用于会话持久化) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    
    <!-- JSON 处理 -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
    
    <!-- Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

## 💡 MVP 功能清单

### **第一阶段：基础对话** (Week 1)
- ✅ WebSocket 实时对话连接
- ✅ 简单状态管理（GREETING → COLLECTING → RECOMMENDING）
- ✅ LangChain4j AI Service 集成
- ✅ 基础对话记忆（MessageWindowChatMemory）
- ✅ 信息提取（从自然语言 → 结构化数据）

### **第二阶段：信息收集** (Week 2)
- ✅ PatientInfo 模型设计
- ✅ 智能追问逻辑
- ✅ 信息完整度判断
- ✅ 多轮对话上下文保持
- ✅ 会话状态持久化（内存 → Redis）

### **第三阶段：推荐引擎** (Week 3)
- ✅ 症状 → 科室映射
- ✅ 医生推荐（基于科室、专长、评分）
- ✅ 非处方药推荐 + 免责声明
- ✅ 推荐结果格式化展示
- ✅ 结果反馈机制

### **第四阶段：优化** (Week 4)
- ✅ 前端界面美化
- ✅ 错误处理和重试机制
- ✅ 日志记录和监控
- ✅ 性能优化
- ✅ 单元测试

## 🎯 核心优势（相比 LangGraph4j）

### **为什么不用 LangGraph4j？**

1. **简化开发**：不需要学习新的状态机框架
2. **降低复杂度**：MVP 阶段状态转换简单，用 if-else 就够了
3. **易于调试**：状态流程清晰可见，容易排查问题
4. **灵活性高**：随时可以调整状态逻辑，不受框架限制
5. **依赖更少**：减少第三方依赖，降低维护成本

### **何时考虑升级到 LangGraph4j？**

- 状态数量 > 10 个
- 状态转换逻辑非常复杂
- 需要并行处理多个状态
- 需要复杂的条件分支和循环
- 需要可视化状态流程图

## 🔥 关键技术点

### **1. LangChain4j AiServices**

使用声明式接口定义 AI 助手：

```java
@Service
public interface MedicalAssistant {
    
    @SystemMessage(fromResource = "prompts/info-collection.txt")
    @UserMessage("用户说：{{it}}")
    String chat(String userMessage);
    
    @SystemMessage("提取患者信息，返回 JSON 格式")
    PatientInfo extractInfo(String conversation);
}

// 配置
MedicalAssistant assistant = AiServices.builder(MedicalAssistant.class)
    .chatLanguageModel(chatModel)
    .chatMemory(chatMemory)
    .tools(new MedicalTools())
    .build();
```

### **2. ChatMemory 管理**

```java
@Configuration
public class LangChainConfig {
    
    @Bean
    public ChatMemoryProvider chatMemoryProvider() {
        return sessionId -> MessageWindowChatMemory.builder()
            .maxMessages(20)  // 保留最近 20 条消息
            .id(sessionId)
            .build();
    }
}
```

### **3. Tools 定义**

```java
public class MedicalTools {
    
    @Tool("根据症状推荐科室")
    public String recommendDepartment(
        @P("主要症状") String symptom
    ) {
        // 实现逻辑
    }
    
    @Tool("检查信息是否完整")
    public boolean isInfoComplete(
        @P("患者信息") PatientInfo info
    ) {
        return info.isReadyForRecommendation();
    }
}
```

### **4. WebSocket 配置**

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(chatWebSocketHandler(), "/ws/chat")
                .setAllowedOrigins("*");
    }
    
    @Bean
    public WebSocketHandler chatWebSocketHandler() {
        return new ChatWebSocketHandler();
    }
}
```

## ⚠️ 重要注意事项

### **1. 医疗合规性**
- ❌ **不能**：诊断疾病、开具处方药
- ✅ **可以**：收集症状、推荐科室、推荐 OTC 药物
- 🔴 **必须**：在每次推荐后添加免责声明

### **2. 数据隐私**
- 敏感数据加密存储
- 符合《个人信息保护法》
- 定期清理过期会话数据
- 不得泄露用户健康信息

### **3. 性能优化**
- WebSocket 连接池管理
- 会话超时自动清理（30分钟无活动）
- LLM 调用超时设置（30秒）
- 使用流式响应（Streaming）提升体验

### **4. 错误处理**
- LLM 调用失败的降级策略
- WebSocket 断线重连
- 异常信息用户友好化

## 📊 数据准备

### **doctors.json 示例**

```json
[
  {
    "id": "D001",
    "name": "张医生",
    "department": "内科",
    "specialty": "呼吸系统疾病",
    "title": "主任医师",
    "rating": 4.8,
    "experience": 15,
    "hospital": "市第一人民医院"
  },
  {
    "id": "D002",
    "name": "李医生",
    "department": "神经内科",
    "specialty": "头痛、头晕",
    "title": "副主任医师",
    "rating": 4.6,
    "experience": 10,
    "hospital": "市中医院"
  }
]
```

### **medicines.json 示例**

```json
[
  {
    "id": "M001",
    "name": "布洛芬缓释胶囊",
    "category": "解热镇痛药",
    "symptoms": ["头痛", "发热", "牙痛"],
    "dosage": "成人一次1粒，一日2次",
    "contraindications": "孕妇、哺乳期妇女禁用",
    "sideEffects": "可能引起胃肠不适",
    "price": 12.5
  }
]
```

### **symptom-department-mapping.json**

```json
{
  "头痛": ["神经内科", "疼痛科"],
  "发烧": ["内科", "急诊科"],
  "咳嗽": ["呼吸科", "内科"],
  "胃痛": ["消化内科", "普外科"],
  "胸痛": ["心内科", "呼吸科", "急诊科"],
  "皮疹": ["皮肤科", "过敏科"]
}
```

## 🚀 下一步行动

**我可以立即帮您：**

1. ✅ **生成完整项目代码** - 所有 Java 类、配置文件、前端代码
2. ✅ **配置 LangChain4j** - application.yml + LangChainConfig
3. ✅ **实现核心状态管理** - StateManager + Handlers
4. ✅ **WebSocket 通信** - 完整的实时对话功能
5. ✅ **准备测试数据** - doctors.json + medicines.json
6. ✅ **创建简单前端** - HTML + JS 聊天界面

---

## 📝 总结

本设计采用 **LangChain4j + 简单状态模式 + WebSocket** 的架构：

- 🎯 **核心思路**：不使用复杂的状态机框架，用简单的状态管理器 + 处理器模式
- 🚀 **快速开发**：减少学习成本，专注业务逻辑
- 🔧 **易于维护**：代码结构清晰，逻辑简单
- 📈 **可扩展**：后期可根据需要升级到 LangGraph4j

**适合 MVP 快速验证，2-3 周即可完成核心功能！**

