# 在线用户功能说明

## 📋 功能概述

已在 STOMP 点对点消息系统中添加**实时在线用户展示**功能。

### ✨ 核心特性

- ✅ **实时显示在线用户列表**
- ✅ **自动监听用户上下线**
- ✅ **显示在线用户数量**
- ✅ **点击用户名快速发私信**
- ✅ **当前用户高亮显示**
- ✅ **用户上下线系统通知**

---

## 🏗️ 实现原理

### 架构设计

```
┌─────────────────────────────────────────────────────┐
│              WebSocketEventListener                 │
│  ┌──────────────────────────────────────────────┐  │
│  │  监听连接事件                                 │  │
│  │  • SessionConnectedEvent  (用户上线)         │  │
│  │  • SessionDisconnectEvent (用户下线)         │  │
│  └──────────────────────────────────────────────┘  │
│                                                      │
│  ┌──────────────────────────────────────────────┐  │
│  │  在线用户管理                                 │  │
│  │  • Set<String> onlineUsers (线程安全)        │  │
│  │  • 添加/删除用户                             │  │
│  └──────────────────────────────────────────────┘  │
│                                                      │
│  ┌──────────────────────────────────────────────┐  │
│  │  广播用户状态                                 │  │
│  │  • /topic/user-status                        │  │
│  │  • 包含：userId, status, onlineUsers         │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                          │
                          ↓
                 所有订阅的客户端收到
```

---

## 📁 涉及的文件

### 后端文件

1. **`WebSocketEventListener.java`** - 新增文件 ⭐
   - 监听 WebSocket 连接和断开事件
   - 维护在线用户集合
   - 广播用户状态变化

### 前端文件

2. **`test-stomp-p2p.html`** - 已修改 ⭐
   - 添加在线用户 UI
   - 订阅用户状态更新
   - 实时更新在线用户列表

---

## 🔑 核心代码

### 后端：WebSocketEventListener

```java
@Component
@Slf4j
public class WebSocketEventListener {
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    
    // 在线用户集合（线程安全）
    private final Set<String> onlineUsers = ConcurrentHashMap.newKeySet();
    
    // 监听用户上线
    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        Principal user = headerAccessor.getUser();
        if (user != null) {
            String userId = user.getName();
            onlineUsers.add(userId);
            
            // 广播用户上线通知
            broadcastUserStatus(userId, "online", onlineUsers);
        }
    }
    
    // 监听用户下线
    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        Principal user = headerAccessor.getUser();
        if (user != null) {
            String userId = user.getName();
            onlineUsers.remove(userId);
            
            // 广播用户下线通知
            broadcastUserStatus(userId, "offline", onlineUsers);
        }
    }
    
    // 广播用户状态
    private void broadcastUserStatus(String userId, String status, Set<String> currentOnlineUsers) {
        Map<String, Object> statusMessage = Map.of(
            "type", "user_status",
            "userId", userId,
            "status", status,
            "onlineUsers", currentOnlineUsers,
            "onlineCount", currentOnlineUsers.size()
        );
        
        messagingTemplate.convertAndSend("/topic/user-status", statusMessage);
    }
}
```

---

### 前端：订阅用户状态

```javascript
// 订阅用户状态（上线/下线）
function subscribeToUserStatus() {
    const subscription = stompClient.subscribe('/topic/user-status', function(message) {
        const data = JSON.parse(message.body);
        
        if (data.type === 'user_status') {
            // 更新在线用户列表
            onlineUsers = new Set(data.onlineUsers);
            updateOnlineUserList();
            
            // 显示系统消息
            if (data.status === 'online' && data.userId !== currentUserId) {
                addSystemMessage(`${data.userId} 上线了`);
            } else if (data.status === 'offline' && data.userId !== currentUserId) {
                addSystemMessage(`${data.userId} 下线了`);
            }
        }
    });
}
```

---

### 前端：更新在线用户列表

```javascript
function updateOnlineUserList() {
    const listDiv = document.getElementById('onlineUserList');
    const countSpan = document.getElementById('onlineUserCount');
    
    countSpan.textContent = onlineUsers.size;
    
    if (onlineUsers.size === 0) {
        listDiv.innerHTML = '<div style="color: #999;">暂无在线用户</div>';
    } else {
        listDiv.innerHTML = '';
        
        // 将在线用户列表转换为数组并排序（当前用户排在第一位）
        const sortedUsers = Array.from(onlineUsers).sort((a, b) => {
            if (a === currentUserId) return -1;
            if (b === currentUserId) return 1;
            return a.localeCompare(b);
        });
        
        sortedUsers.forEach(userId => {
            const badge = document.createElement('span');
            badge.className = userId === currentUserId ? 'user-badge me' : 'user-badge';
            badge.textContent = userId === currentUserId ? `${userId} (我)` : userId;
            
            // 点击用户名自动填充到私信目标
            if (userId !== currentUserId) {
                badge.style.cursor = 'pointer';
                badge.onclick = function() {
                    document.getElementById('targetUserId').value = userId;
                    document.getElementById('privateMessageInput').focus();
                };
                badge.title = '点击发送私信';
            }
            
            listDiv.appendChild(badge);
        });
    }
}
```

---

## 📨 消息格式

### 用户状态消息

**广播到**：`/topic/user-status`

**消息格式**：
```json
{
    "type": "user_status",
    "userId": "Alice",
    "status": "online",  // 或 "offline"
    "onlineUsers": ["Alice", "Bob", "Charlie"],
    "onlineCount": 3
}
```

---

## 🎨 UI 展示

### 在线用户面板

```
┌─────────────────────────────────────┐
│ 👥 在线用户 (3)                     │
├─────────────────────────────────────┤
│  [Alice (我)]  [Bob]  [Charlie]     │
│                                     │
│  • 蓝色：当前用户                   │
│  • 绿色：其他用户                   │
│  • 点击：快速发私信                 │
└─────────────────────────────────────┘
```

### 特色功能

1. **当前用户高亮**
   - 当前用户显示为蓝色 badge
   - 标注"(我)"

2. **点击快速私信**
   - 点击其他用户名
   - 自动填充到私信目标
   - 焦点移动到消息输入框

3. **动画效果**
   - 用户上线淡入动画
   - 平滑的过渡效果

---

## 🧪 测试指南

### 测试场景 1：双用户上下线

**步骤**：

1. **打开第一个浏览器标签页**
   - 用户ID：`Alice`
   - 点击"连接"
   - 验证在线用户列表显示：`Alice (我)`

2. **打开第二个浏览器标签页**
   - 用户ID：`Bob`
   - 点击"连接"
   - **Alice 的标签页**应该看到：
     - 系统消息："Bob 上线了"
     - 在线用户列表更新为：`Alice (我)`, `Bob`
   - **Bob 的标签页**应该看到：
     - 在线用户列表显示：`Bob (我)`, `Alice`

3. **Bob 断开连接**
   - 在 Bob 的标签页点击"断开"
   - **Alice 的标签页**应该看到：
     - 系统消息："Bob 下线了"
     - 在线用户列表更新为：`Alice (我)`

---

### 测试场景 2：快速发私信

**步骤**：

1. **连接两个用户**：Alice 和 Bob

2. **在 Alice 的标签页**
   - 点击在线用户列表中的 `Bob`
   - 验证：
     - "目标用户ID"输入框自动填充为 `Bob`
     - 焦点移动到"私信内容"输入框

3. **输入消息并发送**
   - 输入：`你好，Bob！`
   - 点击"发送"
   - 验证 Bob 收到消息

---

### 测试场景 3：多用户同时在线

**步骤**：

1. **打开 4 个浏览器标签页**
   - user001, user002, user003, user004

2. **依次连接**
   - 观察每个标签页的在线用户列表
   - 验证在线人数统计正确

3. **随机断开某个用户**
   - 观察其他标签页的系统通知
   - 验证在线用户列表实时更新

---

## 🔧 配置说明

### 订阅路径

前端需要订阅以下路径：

```javascript
// 用户状态更新
stompClient.subscribe('/topic/user-status', callback);
```

### 广播路径

后端通过以下路径广播用户状态：

```java
messagingTemplate.convertAndSend("/topic/user-status", statusMessage);
```

---

## 💡 扩展建议

### 1. 添加用户头像

```javascript
badge.innerHTML = `
    <img src="/api/users/${userId}/avatar" class="user-avatar">
    ${userId === currentUserId ? userId + ' (我)' : userId}
`;
```

### 2. 显示用户在线时长

```java
private final Map<String, Long> userLoginTime = new ConcurrentHashMap<>();

@EventListener
public void handleWebSocketConnectListener(SessionConnectedEvent event) {
    String userId = ...;
    userLoginTime.put(userId, System.currentTimeMillis());
    // ...
}
```

### 3. 用户状态（在线/忙碌/离开）

```java
private enum UserStatus {
    ONLINE, BUSY, AWAY
}

private final Map<String, UserStatus> userStatuses = new ConcurrentHashMap<>();
```

### 4. 用户搜索/过滤

```javascript
function filterUsers(keyword) {
    const filtered = Array.from(onlineUsers).filter(u => 
        u.toLowerCase().includes(keyword.toLowerCase())
    );
    updateOnlineUserList(filtered);
}
```

---

## 🚨 注意事项

### 1. 线程安全

使用 `ConcurrentHashMap.newKeySet()` 创建线程安全的 Set：

```java
private final Set<String> onlineUsers = ConcurrentHashMap.newKeySet();
```

### 2. 事件监听时机

- `SessionConnectedEvent`：在 STOMP CONNECTED 帧之后触发
- `SessionDisconnectEvent`：在连接关闭后触发

### 3. 用户身份获取

必须在连接时设置 Principal：

```java
// 在 ChannelInterceptor 中设置
accessor.setUser(() -> userId);
```

### 4. 内存管理

定期清理断开连接但未触发事件的用户（可选）：

```java
@Scheduled(fixedRate = 60000) // 每分钟
public void cleanupStaleUsers() {
    // 清理逻辑
}
```

---

## 📊 性能考虑

### 优化建议

1. **批量更新**
   - 如果短时间内多个用户上下线
   - 可以考虑批量发送状态更新

2. **增量更新**
   - 仅发送变化的用户
   - 而不是每次都发送完整列表

3. **压缩**
   - 对于大量在线用户
   - 考虑压缩用户列表数据

---

## ✅ 总结

✅ **功能完整**：实时显示在线用户列表  
✅ **用户体验好**：点击用户名快速发私信  
✅ **实时性强**：自动监听上下线事件  
✅ **代码优雅**：使用 Spring 事件机制  
✅ **易于扩展**：可添加更多用户状态功能  

---

**相关文件**：
- 后端：`src/main/java/com/yihu/agent/websocket/WebSocketEventListener.java`
- 前端：`Front/test-stomp-p2p.html`

**测试页面**：直接打开 `Front/test-stomp-p2p.html` 即可体验！

---

**祝你使用愉快！** 🎉

